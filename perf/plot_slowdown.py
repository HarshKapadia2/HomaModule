#!/usr/bin/python3

# Copyright (c) 2020, Stanford University
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# This script generates a plot of slowdown as a function of message
# length, with an x-axis scaled to match the CDF of message lengths.
#
# Usage: plot_slowdown.py log_dir
#
# "log_dir" is the name of a directory containing log files created by
# "cperf slowdown"

import glob
import math
import matplotlib.pyplot as plt
import numpy as np
import os
import string
import sys

# Keys are message lengths, values are median unloaded RTTs.
unloaded = {}

# Keys are message lengths, values are number of messages of that length.
counts = {}

# Keys are message lengths; each value is a list of all times recorded
# on all servers for that message length, in microseconds.
rtts = {}

# Keys are message lengths; each value is the cumulative fraction of messages
# whose length is <= the key.
cum_frac = {}

def get_unloaded(file):
    """
    Read file (generated by cp_node's "dump_times" command) and use its
    data to fill in the unloaded dictionary.
    """
    global unloaded

    # Each element holds a list of all the RTTs measured for a given
    # message length, in microseconds.
    times = {}
    f = open(file, "r")
    for line in f:
        stripped = line.strip();
        if stripped[0] == '#':
            continue
        words = stripped.split()
        if (len(words) < 2):
            print("Line too short (need at least 2 columns): '%s'" % (line))
            continue
        length = int(words[0])
        usec = float(words[1])
        if length in times:
            times[length].append(usec)
        else:
            times[length] = [usec]
    f.close()
    lengths = sorted(times.keys())
    for length in lengths:
        unloaded[length] = sorted(times[length])[len(times[length])//2]
        # print("Length%10d: %.1f usec (%d values)" % (length, unloaded[length],
        #         len(times[length])))

def read_loaded(file):
    """
    Read file (generated by cp_node's "dump_times" command) and add its
    data to the counts and rtts global arrays.
    """
    global rtts, counts

    f = open(file, "r")
    for line in f:
        stripped = line.strip();
        if stripped[0] == '#':
            continue
        words = stripped.split()
        if (len(words) < 2):
            print("Line too short (need at least 2 columns): '%s'" % (line))
            continue
        length = int(words[0])
        usec = float(words[1])
        if length in counts:
            counts[length] += 1
            rtts[length].append(usec)
        else:
            counts[length] = 1
            rtts[length] = [usec]
    f.close()

def make_plot(files):
    """
    The files argument is a list of filenames. Read data from all of these
    files and generate plot data in global variables.
    """
    global rtts, counts, cum_frac, x, y_p50, y_p99, y_p999, total, lengths

    rtts = {}
    counts = {}
    cum_frac = {}
    for file in files:
        print("Reading data from %s" % (file))
        read_loaded(file)

    # Compute cum_frac
    lengths = sorted(counts.keys())
    total = 0
    cumulative = 0
    for length in lengths:
        total += counts[length]
    for length in lengths:
        cumulative += counts[length]
        cum_frac[length] = cumulative/total

    # Generate plot data
    min_count = 0
    min_length = 0
    p50 = 0
    p99 = 0
    p999 = 0
    x = []
    y_p50 = []
    y_p99 = []
    y_p999 = []
    for length in lengths:
        if not length in unloaded:
            continue
        sorted_times = sorted(rtts[length])
        count = len(sorted_times)
        if (min_length == 0) or (count < min_count):
            min_count = count
            min_length = length
        if len(x) > 0:
            x.append(cum_frac[length])
            y_p50.append(p50)
            y_p99.append(p99)
            y_p999.append(p999)
        x.append(cum_frac[length])
        p50 = sorted_times[count//2]/unloaded[length]
        p99 = sorted_times[count*99//100]/unloaded[length]
        p999 = sorted_times[count*999//1000]/unloaded[length]
        print("length %d, p50 %.1f, p99 %.1f, p999 %.1f, count %d, p999 index %d"
                % (length, p50, p99, p999, count, count*999//1000))
        y_p50.append(p50)
        y_p99.append(p99)
        y_p999.append(p999)
    print("There are only %d times for length %d" % (min_count, min_length))


if len(sys.argv) != 2:
    print("Usage: %s name log_dir" % (sys.argv[0]))
    exit(1)
log_dir = sys.argv[1]

print("Reading unloaded data")
get_unloaded(log_dir + "/unloaded.txt")
make_plot(glob.glob(log_dir + "/loaded-*.txt"))

plt.figure(figsize=[6, 3])
plt.rcParams.update({'font.size': 10})
plt.axis()
plt.xlim(0, 1.0)
plt.yscale("log")
# plt.ylim(1, 100)
plt.xlabel("Message Length (KB)")
plt.ylabel("Slowdown")
plt.grid(which="major", axis="y")

# Generate x-axis labels
xticks = []
xlabels = []
i = 0
length = 0
cumulative = 0
for tick in range(0, 11):
    frac = tick/10
    xticks.append(frac)
    while (cumulative/total < frac) and (i < len(lengths)):
        length = lengths[i]
        cumulative += counts[length]
        i += 1
    kb = length/1000.0
    if kb < 3.0:
        xlabels.append("%.2f" % (kb))
    elif kb < 30.0:
        xlabels.append("%.1f" % (kb))
    else:
        xlabels.append("%.0f" % (kb))
plt.xticks(xticks, xlabels)

plt.plot(x, y_p50, label="Homa P50")
plt.plot(x, y_p99, label="Homa P99")
make_plot(glob.glob(log_dir + "/tcp-*.txt"))
plt.plot(x, y_p50, label="TCP P50")
plt.plot(x, y_p99, label="TCP P99")
plt.legend()
plt.tight_layout()

plt.savefig("%s/slowdown.pdf" % (log_dir))
    