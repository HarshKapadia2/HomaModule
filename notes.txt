Notes for Homa implementation in Linux:
---------------------------------------

* Things to do:
  * Figure out socket locking disciplines.
  * Many unimplemented interface functions.
  * Learn about CONFIG_COMPAT and whether it needs to be supported in
    struct proto and struct proto_ops.
  * Learn about security stuff, and functions that need to be called for this.
  * Learn about memory management for sk_buffs: how many is it OK to have?
  * Initially using simple lists for all tables; will need to replace with
    something more efficient.
  * Eventually initialize homa.next_client_port to something random
  * homa_message_out_init: compute unscheduled bites and priority better.
  * Routes: what is the lifetime of these? How long can I retain a pointer?

* Port numbers:
  * Shouldn't be visible to clients; only needed for servers.
  * Bind is only needed to receive requests.
  * What if port space is partitioned?
    * 32 bits total
    * Low-order 16 bits: server ports (bound)
    * Others: client ports
      * Pick a random starting position on reboot
      * Allocate ports sequentially to mazimize time between reuse.
      * Or, just pick ports at random always (no predictability,
        better for security)?
    * Are FROM_CLIENT and FROM_SERVER needed still? Can deduce from
      the port numbers.
    * A server will have 2 port numbers: one used for to receive requests
      and another to send requests.

* On send:
  * Immediately copy message into sk_buffs.
  * Client assigns message id; it's the first 8 bytes of the message data.
  * Return before sending entire message.
  * Homa keeps track of outstanding requests (some limit per socket?).
  * If message fails, kernel must fabricate a response. Perhaps all
    responses start with an id and a status?

* Tables needed:
  * All Homa sockets
    * Used to assign new port numbers
    * Used to dispatch incoming packets
    * Need RCU or some other kind of locking?
  * Outgoing RPCs (for a socket?)
    * Used to find state for incoming packets
    * Used for cleanup operations (socket closure, cancellation, etc.)
    * Used for detecting timeouts
    * No locks needed: use existing socket lock
    * Or, have one table for all sockets?
  * Outgoing requests that haven't yet been transmitted:
    * For scheduling outbound traffic
    * Must be global?
  * Outgoing responses that haven't yet been transmitted:
    * For scheduling outbound traffic
    * Must be global?
  * Incoming RPCs:
    * Use to find state for incoming packets

* C++ data structures used in HomaTransport:
  * MessageAccumulator: std::vector of received packets, Buffer of
    assembled message
  * HomaTransport:
    * vectors of packets and messages
    * hash of outgoing RPCs
    * list of outgoing RPCs that haven't yet been transmitted
    * hash of incoming RPCs
    * list of RPCs that require timer attention

* Miscellaneous information:
  * For raw sockets: "man 7 raw"
  * Per-cpu data structures: linux/percpu.h, percpu-defs.h

* API for applications
  * Ideally, sends are asynchronous:
    * The send returns before the message has been sent
    * Data has been copied out of application-level buffers, so
      buffers can be reused
  * Must associate requests and responses:
    * A response is different from a request.
    * Kernel may need to keep track of open requests, so that it
      can handle RESEND packets appropriately; what if application
      doesn't respond, and an infinite backlog of open requests
      builds up? Must limit the kernel state that accumulates.
    * Maybe application must be involved in RESENDs?
  * On receive, application must provide space for largest possible message
    * Or, receives must take 2 system calls, one to get the size and
      one to get the message.
  * Support a polling API for incoming messages?
    * Client provides buffer space in advance
    * Kernel fills in data as packets arrive
    * Client can poll memory to see when new messages arrive
    * This would minimize sk_buff usage in the kernel
    * Is there a way for the kernel to access client memory when
      the process isn't active?
    * Can buffer space get fragmented? For example, the first part of
      a long message arrives, but the rest doesn't; meanwhile, buffers
      fill up and wrap around.
  * On receive, avoid copies of large message bodies? E.g., deliver only
    header to the application, then it can come back later and request
    that the body be copied to a particular spot.
  * Provide a batching mechanism to avoid a kernel call for each message?

* What happens when a socket is closed?
  * socket.c:sock_close
    * socket.c:sock_release
      * proto_ops.release -> af_inet.c:inet_release)
      * af_inet.c:inet_release doesn't appear to do anything relevant to Homa
        * proto.close -> sock.c:sk_common_release?)
          * proto.unhash
          * sock_orphan
          * sock_put (decrements ref count, frees)

* What happens in a connect syscall (UDP)?
  * socket.c:sys_connect
    * proto_ops.connect -> af_inet.c:inet_dgram_connect
      * proto.connect -> datagram.c:ip4_datagram_connect
        * datagram.c: __ip4_datagram_connect

* What happens in a bind syscall (UDP)?
  * socket.c:sys_bind
    * proto_ops.bind -> afinet.c:inet_bind
      * proto.bind -> (not defined for UDP)
      * If no proto.bind handler, then a bunch of obscure -looking stuff
        happens.

* What happens in a sendmsg syscall (UDP)?
  * socket.c:sys_sendmsg
    * socket.c:__sys_sendmsg
      * socket.c:___sys_sendmsg
        * Copy to msghdr and control info to kernel space
        * socket.c:sock_sendmsg
          * socket.c:sock_sendmsg_nosec
          * proto_ops.sendmsg -> afinet.c:inet_sendmsg
            * Auto-bind socket, if not bound
            * proto.sendmsg -> udp.c:udp_sendmsg
              * Long method ...
              * ip_output.c:ip_make_skb
                * Seems to collect data for the datagram?
                * __ip_append_data
              * udp.c:udp_send_skb
                * Creates UDP header
                * ip_output.c:ip_send_skb
                  * ip_local_out
