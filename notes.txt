Notes for Homa implementation in Linux:
---------------------------------------

* Things to do:
  * Figure out socket locking disciplines.
  * Many unimplemented interface functions.
  * Learn about CONFIG_COMPAT and whether it needs to be supported in
    struct proto and struct proto_ops.
  * Learn about security stuff, and functions that need to be called for this.
  * Learn about memory management for sk_buffs: how many is it OK to have?

* C++ data structures used in HomaTransport:
  * MessageAccumulator: std::vector of received packets, Buffer of
    assembled message
  * HomaTransport:
    * vectors of packets and messages
    * hash of outgoing RPCs
    * list of outgoing RPCs that haven't yet been transmitted
    * hash of incoming RPCs
    * list of RPCs that require timer attention

* Miscellaneous information:
  * For raw sockets: "man 7 raw"
  * Per-cpu data structures: linux/percpu.h, percpu-defs.h

* API for applications
  * Ideally, sends are asynchronous:
    * The send returns before the message has been sent
    * Data has been copied out of application-level buffers, so
      buffers can be reused
  * Must associate requests and responses:
    * A response is different from a request.
    * Kernel may need to keep track of open requests, so that it
      can handle RESEND packets appropriately; what if application
      doesn't respond, and an infinite backlog of open requests
      builds up? Must limit the kernel state that accumulates.
    * Maybe application must be involved in RESENDs?
  * On receive, application must provide space for largest possible message
    * Or, receives must take 2 system calls, one to get the size and
      one to get the message.
  * Support a polling API for incoming messages?
    * Client provides buffer space in advance
    * Kernel fills in data as packets arrive
    * Client can poll memory to see when new messages arrive
    * This would minimize sk_buff usage in the kernel
    * Is there a way for the kernel to access client memory when
      the process isn't active?
    * Can buffer space get fragmented? For example, the first part of
      a long message arrives, but the rest doesn't; meanwhile, buffers
      fill up and wrap around.
  * On receive, avoid copies of large message bodies? E.g., deliver only
    header to the application, then it can come back later and request
    that the body be copied to a particular spot.
  * Provide a batching mechanism to avoid a kernel call for each message?

* What happens when a socket is closed?
  * socket.c:sock_close
    * socket.c:sock_release
      * proto_ops.release -> af_inet.c:inet_release)
      * af_inet.c:inet_release doesn't appear to do anything relevant to Homa
        * proto.close -> sock.c:sk_common_release?)
          * proto.unhash
          * sock_orphan
          * sock_put (decrements ref count, frees)

* What happens in a connect syscall (UDP)?
  * socket.c:sys_connect
    * proto_ops.connect -> af_inet.c:inet_dgram_connect
      * proto.connect -> datagram.c:ip4_datagram_connect
        * datagram.c: __ip4_datagram_connect

* What happens in a bind syscall (UDP)?
  * socket.c:sys_bind
    * proto_ops.bind -> afinet.c:inet_bind
      * proto.bind -> (not defined for UDP)
      * If no proto.bind handler, then a bunch of obscure -looking stuff
        happens.

* What happens in a sendmsg syscall (UDP)?
  * socket.c:sys_sendmsg
    * socket.c:__sys_sendmsg
      * socket.c:___sys_sendmsg
        * Copy to msghdr and control info to kernel space
        * socket.c:sock_sendmsg
          * socket.c:sock_sendmsg_nosec
          * proto_ops.sendmsg -> afinet.c:inet_sendmsg
            * Auto-bind socket, if not bound
            * proto.sendmsg -> udp.c:udp_sendmsg
              * Long method ...
              * ip_output.c:ip_make_skb
                * Seems to collect data for the datagram?
                * __ip_append_data
              * udp.c:udp_send_skb
                * Creates UDP header
                * ip_output.c:ip_send_skb
                  * ip_local_out
